var relearn_searchindex = [
  {
    "breadcrumb": "Introduction \u003e Quick-start",
    "content": "Dependencies JUnit 5 - At least 5.10.x\ntest dependencies in pom.xml \u003cdependency\u003e \u003cgroupId\u003eguru.mikelue.foxglove\u003c/groupId\u003e \u003cartifactId\u003ecore\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.10.5\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Extension Package: guru.mikelue.foxglove.junit\nUse FoxgloveJUnitExtension to enable Foxglove on JUnit 5 tests.\nAnnotations Package: guru.mikelue.foxglove.junit.annotation\n@TableFacetsSource - Annotation to provide TableFacet(s) for the test class.\n@DataGeneratorSource - Annotation to provide DataGenerator(s) for the test class.\n@GenData - Annotation to enable data generation for test methods or test class.\nvalue - Array of TableFacetsProvider(s) defining the table facets.\nfacets - Array of TableFacetsProvider(s) defining the table facets.\nfacetsNames - Names of fields or methods, which are type of TableFacet, List\u003cTableFacet\u003e, Stream\u003cTableFacet\u003e or TableFacetsProvider.\ngenerator - Type of DataGeneratorProvider providing DataGenerator.\ngeneratorName - Name of DataGenerator.\nExamples Warning Since JdbcTableFacet is not reusable, you should not use @TableFacetSource field when you are using @TestInstance(Lifecycle.PER_CLASS).\nUse TableFacetProvider for @TableFacetSource fields while you are using @TestInstance(Lifecycle.PER_CLASS)\nSee JUnit 5 Examples for complete examples.\nFor @GenData - If none of properties provided, the extension will looking for @TableFacetsSource and @DataGeneratorSource on the test class.\nUsage of FoxgloveJUnitExtension import guru.mikelue.foxglove.annotation.*; import guru.mikelue.foxglove.jdbc.JdbcDataGenerator; import guru.mikelue.foxglove.jdbc.JdbcTableFacet; import guru.mikelue.foxglove.junit.FoxgloveJUnitExtension; @ExtendWith(FoxgloveJUnitExtension.class) public class JUnit5Test extends AbstractJdbcTestBase { private final static int RANDOM_ROWS = gen().ints().range(5, 10).get(); public JUnit5Test() {} /** * For @GenData, the name will be same as the method name. */ @Test @GenData(facetsNames = { \"carsWithFeature\" }) void junit5Method() { int testedCount = getJdbcTemplate().query( \"\"\" SELECT COUNT(DISTINCT cr_id) FROM ap_car INNER JOIN ap_car_feature ON cr_id = cf_cr_id AND cf_feature_name = 'Sunroof' \"\"\", rs -\u003e { rs.next(); return rs.getInt(1); } ); assertThat(testedCount) .isEqualTo(RANDOM_ROWS); } @TableFacetsSource TableFacet[] carsWithFeature() { var carFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_ROWS) .build(); return new TableFacet[] { carFacet, JdbcTableFacet.builder(TABLE_CAR_FEATURE) .referencing(\"cf_cr_id\") .parent(carFacet, \"cr_id\") .cardinality(2) .column(\"cf_feature_name\") .roundRobin(\"Sunroof\", \"Leather Seats\") .build() }; } /** * Default data generator for JDBC. */ @DataGeneratorSource DataGenerator\u003c?\u003e defaultDataGenerator() { return new JdbcDataGenerator(getDataSource()); } @BeforeEach void setup() {} @AfterEach void tearDown() { deleteAll(TABLE_CAR); } } Functional utility types Package: guru.mikelue.foxglove.junit.functional\nTableFacetsProvider - A Supplier of List\u003cTableFacet\u003e to provide table facets for the test class.\nTableFacetProvider - A Supplier of TableFacet to provide single table facet for the test class.\nStreamOfTableFacetsProvider - A Supplier of Stream\u003cTableFacet\u003e to provide table facets for the test class.\nReferences",
    "description": "JUnit 5 integration of Foxglove",
    "tags": [],
    "title": "JUnit 5",
    "uri": "/quickstart/junit/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Quick-start",
    "content": "Dependencies SpringFramework - At least 6.0.x\nSpringBoot(Optional) - At least 3.1.x\nIt would be more convenient using SpringBoot for your tests.\ntest dependencies in pom.xml \u003cdependency\u003e \u003cgroupId\u003eguru.mikelue.foxglove\u003c/groupId\u003e \u003cartifactId\u003ecore\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.10.5\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003cversion\u003e3.1.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cversion\u003e3.1.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Usage Package: guru.mikelue.foxglove.springframework\nUse EnableFoxglove with your SpringFramework tests.\nOr add FoxgloveTestListener to TestExecutionListeners of your test class.\nExamples JUnit 5 Examples for more examples of usage for @GenData, @DataGeneratorSource and @TableFacetsSource.\nSpringFramwork Examples for more examples of application context and class-level sources for Foxglove.\nSampleTestConfig is shown in this page\nimport org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase; import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace; import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.jdbc.JdbcTestUtils; import guru.mikelue.foxglove.TableFacet; import guru.mikelue.foxglove.annotation.GenData; import guru.mikelue.foxglove.annotation.TableFacetsSource; import guru.mikelue.foxglove.jdbc.JdbcTableFacet; import guru.mikelue.foxglove.springframework.EnableFoxglove; @JdbcTest @AutoConfigureTestDatabase(replace = Replace.NONE) @ContextConfiguration(classes = SampleTestConfig.class) @EnableFoxglove public class SpringFrameworkTest { public SpringFrameworkTest() {} @TableFacetsSource TableFacet redCars = JdbcTableFacet.builder(\"ap_car\") .numberOfRows(RANDOM_ROWS) .column(\"cr_color\").fixed(\"red\") .build(); /** * The default transaction behavior of @JdbcTest is to rollback at the end of each test. */ @Test @GenData( facetsNames = { \"redCars\" } ) void someTest( @Autowired JdbcTemplate jdbcTemplate ) { assertThat( JdbcTestUtils.countRowsInTableWhere( jdbcTemplate, \"ap_car\", \"cr_color = 'red'\" ) ) .isEqualTo(RANDOM_ROWS); } } References @JdbcTest\n@DataJpaTest",
    "description": "SpringFramework integration of Foxglove",
    "tags": [],
    "title": "SpringFramework",
    "uri": "/quickstart/springframework/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Examples",
    "content": "See quick start(facet) for snippets of Table Facet.\nImporting import org.junit.jupiter.api.Nested; import guru.mikelue.foxglove.annotation.DataGeneratorSource; import guru.mikelue.foxglove.annotation.GenData; import guru.mikelue.foxglove.annotation.TableFacetsSource; import guru.mikelue.foxglove.functional.TableFacetProvider; import guru.mikelue.foxglove.jdbc.JdbcTableFacet; Default DataGenerator @DataGeneratorSource DataGenerator\u003c?\u003e defaultDataGenerator() { return new JdbcDataGenerator(getDataSource()); } Basic usage By fields // Use direct object of TableFacet @TableFacetsSource TableFacet carsOfRed = JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"red\") .numberOfRows(RANDOM_ROWS).build(); // Use provider of TableFacet @TableFacetsSource TableFacetProvider\u003cTableFacet\u003e membersInTaipei = () -\u003e JdbcTableFacet.builder(TABLE_MEMBER) .column(\"mb_address\").fixed(\"Taipei, Taiwan 1234 Main St\") .numberOfRows(RANDOM_ROWS).build(); @Test @GenData(facetsNames = { \"carsOfRed\", \"membersInTaipei\" }) void byFields() { /* ... */ } Warning Since JdbcTableFacet is not reusable, you should not use @TableFacetSource field when you are using @TestInstance(Lifecycle.PER_CLASS).\nUse TableFacetProvider for @TableFacetSource fields while you are using @TestInstance(Lifecycle.PER_CLASS)\nBy methods @TableFacetsSource TableFacet carsOfBlue() { return JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"blue\") .numberOfRows(RANDOM_ROWS) .build(); } @TableFacetsSource TableFacet membersInNewYork() { return JdbcTableFacet.builder(TABLE_MEMBER) .column(\"mb_address\").fixed(\"New York, NY 1234 Main St\") .numberOfRows(RANDOM_ROWS) .build(); } @Test @GenData(facetsNames = { \"carsOfBlue\", \"membersInNewYork\" }) void byMethods() { /* ... */ } By provider class static class CarsInSilver implements TableFacetProvider\u003cTableFacet\u003e { @Override public TableFacet getOne() { return JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"silver\") .numberOfRows(RANDOM_ROWS) .build(); } } @Test @GenData({ CarsInSilver.class }) void byProviderClass() { /* ... */ } By named sources @TableFacetsSource(\"carsOfRainbow\") TableFacet carsOfSomeColors = JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\") .roundRobin( \"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\" ) .numberOfRows(RANDOM_ROWS) .build(); @Test @GenData(facetsNames = { \"carsOfRainbow\" }) void byTableFacetWithName() { /* ... */ } References: TableFacetsProvider\nList, Stream, or array of TableFacets By array @TableFacetsSource TableFacet[] carsOfArray() { return new TableFacet[] { JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"coral\") .numberOfRows(RANDOM_ROWS) .build(), JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_model\").fixed(\"GK-001\") .numberOfRows(RANDOM_ROWS) .build() }; } @Test @GenData(facetsNames = { \"carsOfArray\" }) void byArrayOfTableFacet() { /* ... */ } By list @TableFacetsSource List\u003cTableFacet\u003e carsOfList() { return List.of( JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"Crimson\") .numberOfRows(RANDOM_ROWS) .build(), JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_model\").fixed(\"LK-002\") .numberOfRows(RANDOM_ROWS) .build() ); } @Test @GenData(facetsNames = { \"carsOfList\" }) void byListOfTableFacet() { /* ... */ } By stream @TableFacetsSource Stream\u003cTableFacet\u003e carsOfStream() { return Stream.of( JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"BlueViolet\") .numberOfRows(RANDOM_ROWS) .build(), JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_model\").fixed(\"GN-003\") .numberOfRows(RANDOM_ROWS) .build() ); } @Test @GenData(facetsNames = { \"carsOfStream\" }) void byStreamOfTableFacet() { /* ... */ } References: List, Stream\nNested test class Use sources of enclosing class @TableFacetsSource TableFacet carsOfGreen = JdbcTableFacet.builder(TABLE_CAR) .column(\"cr_color\").fixed(\"green\") .numberOfRows(RANDOM_ROWS).build(); @Nested class NestedTest { @Test @GenData(facetsNames = { \"carsOfGreen\" }) void nestedByFields() { assertNumberOfRows( TABLE_CAR, \"cr_color = 'green'\" ) .isEqualTo(RANDOM_ROWS); } } References: Nested Tests",
    "description": "Nested class, field and method level examples for @GenData",
    "tags": [],
    "title": "JUnit 5",
    "uri": "/examples/junit5/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Examples",
    "content": "Importing import org.springframework.transaction.annotation.Transactional; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.jdbc.JdbcTestUtils; import guru.mikelue.foxglove.TableFacet; import guru.mikelue.foxglove.annotation.GenData; import guru.mikelue.foxglove.annotation.TableFacetsSource; import guru.mikelue.foxglove.functional.TableFacetProvider; import guru.mikelue.foxglove.jdbc.JdbcTableFacet; import guru.mikelue.foxglove.springframework.EnableFoxglove; Following example using following context configuration of SpringFramework.\nContext Configuration @Configuration class SampleTestConfig { @Bean ToyotaCarsProvider toyotaCars() { return new ToyotaCarsProvider(); } @Bean @Scope(\"prototype\") TableFacet blueCars() { return JdbcTableFacet.builder(\"ap_car\") .numberOfRows(SpringFrameworkTest.RANDOM_ROWS) .column(\"cr_color\").fixed(\"blue\") .build(); } @Bean TableFacetProvider\u003cTableFacet\u003e yellowCars() { return () -\u003e JdbcTableFacet.builder(\"ap_car\") .numberOfRows(SpringFrameworkTest.RANDOM_ROWS) .column(\"cr_color\").fixed(\"yellow\") .build(); } @Bean @Scope(\"prototype\") TableFacet[] purpleCars() { return new TableFacet[] { JdbcTableFacet.builder(\"ap_car\") .numberOfRows(SpringFrameworkTest.RANDOM_ROWS) .column(\"cr_color\").fixed(\"purple\") .build() }; } } @DataGenSource and @TableFacetsSource is still working if there are no such bean found in Spring’s context.\nNote @Nested tests of JUnit 5 are not supported with SpringFramework integration. Beans Use bean definition as sources of TableFacets @Test @GenData( // Uses the bean name of Spring Framework context facetsNames = { \"blueCars\", \"purpleCars\", \"yellowCars\" } ) void blueCarsTest( @Autowired JdbcTemplate jdbcTemplate ) { assertThat( JdbcTestUtils.countRowsInTableWhere( jdbcTemplate, \"ap_car\", \"cr_color IN ('blue', 'purple', 'yellow')\" ) ) .isEqualTo(RANDOM_ROWS * 3); } Use provider class ToyotaCarsProvider implements TableFacetProvider\u003cTableFacet\u003e { @Override public TableFacet getOne() { return JdbcTableFacet.builder(\"ap_car\") .numberOfRows(SpringFrameworkTest.RANDOM_ROWS) .column(\"cr_brand\").fixed(\"Toyota\") .build(); } } @Test @GenData(ToyotaCarsProvider.class) void byProvider( @Autowired JdbcTemplate jdbcTemplate ) { assertThat( JdbcTestUtils.countRowsInTableWhere( jdbcTemplate, \"ap_car\", \"cr_brand = 'Toyota'\" ) ) .isEqualTo(RANDOM_ROWS); } Transaction Not joining transactions @AfterEach void tearDownForYellowCars( @Autowired JdbcTemplate jdbcTemplate ) { // You have to remove the data by yourself JdbcTestUtils.deleteFromTableWhere( jdbcTemplate, \"ap_car\", \"cr_color = 'yellow'\" ); } @Test @GenData( facetsNames = { \"yellowCars\" } ) @Transactional(propagation = Propagation.NOT_SUPPORTED) void noRollback( @Autowired JdbcTemplate jdbcTemplate ) { assertThat( JdbcTestUtils.countRowsInTableWhere( jdbcTemplate, \"ap_car\", \"cr_color = 'yellow'\" ) ) .isEqualTo(RANDOM_ROWS); }",
    "description": "Examples for SpringFramework integration",
    "tags": [],
    "title": "Spring Framework",
    "uri": "/examples/springframework/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Examples",
    "content": "There are ways to generate data for many-to-many relationships by Foxglove.\ndataGenerator() - A method gives a DataGenerator instance.\nConfined domain of ids Confine the domain for both sides\nUse Cartesian product to generate data for the junction table\nFixed domain // The domain of ids of cars var idsOfCars = LongStream.range(11, 21).boxed() .toList(); // The domain of ids of members var idsOfMembers = LongStream.range(101, 111).boxed() .toList(); /* * Sets up the facets for car and member tables by their domain of ids. */ var carFacet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").domain(idsOfCars) .build(); var memberFacet = JdbcTableFacet.builder(TABLE_MEMBER) .keyOfInt(\"mb_id\").domain(idsOfMembers) .build(); // :~) /* * Uses Cartesian product to set up the many-to-many relationship */ var rentFacet = JdbcTableFacet.builder(TABLE_RENT) .cartesianProduct(\"rt_cr_id\").domain(idsOfCars) .cartesianProduct(\"rt_mb_id\").domain(idsOfMembers) .build(); // :~) dataGenerator() .generate(carFacet, memberFacet, rentFacet); One side referencing Any way to decide the number of rows to referenced side(table)\nUse .referencing(String) for this side\nUse the number of values on referencing side to .cardinality(int)\nFix the domain for another side(table)\nUse .column(String).roundRobin(…​) for this side\nOne-side referencing final int numberOfCars = 10; // The domain of ids of members var idsOfMembers = LongStream.range(101, 111).boxed() .toList(); /* * Can be any way to generate the ids of cars */ var carFacet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").limit(1020, numberOfCars) .build(); // :~) /* * Fixed domain of ids of members */ var memberFacet = JdbcTableFacet.builder(TABLE_MEMBER) .keyOfInt(\"mb_id\").domain(idsOfMembers) .build(); // :~) /* * Uses Cartesian product to set up the many-to-many relationship */ var rentFacet = JdbcTableFacet.builder(TABLE_RENT) // References to the ids of cars .referencing(\"rt_cr_id\").parent(carFacet, \"cr_id\") // The cardinality is the number of members .cardinality(idsOfMembers.size()) // The domain comes from the ids of members .column(\"rt_mb_id\").from(memberFacet, \"mb_id\") // Uses round-robin to cover all members .roundRobin() .build(); // :~) dataGenerator() .generate(carFacet, memberFacet, rentFacet); Of course, you can use .column(\"rt_mb_id\").roundRobin(idsOfMembers) directly.\nTwo side referencing Both of the sides are referencing by cartesianProduct(String)\nOne-side referencing // Any way to generate data for these two tables var carFacet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").limit(1000, 3) .build(); var memberFacet = JdbcTableFacet.builder(TABLE_MEMBER) .keyOfInt(\"mb_id\").limit(2000, 5) .build(); // :~) var rentFacet = JdbcTableFacet.builder(TABLE_RENT) // References to ids of cars .cartesianProduct(\"rt_cr_id\") .referencing(carFacet, \"cr_id\") // References to ids of members .cartesianProduct(\"rt_mb_id\") .referencing(memberFacet, \"mb_id\") .build();",
    "description": "Ways to generate data for many-to-many relationships by Foxglove.",
    "tags": [],
    "title": "Many-to-Many relationship",
    "uri": "/examples/many-to-many/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "Check Table facet(Quick start) for snippets of Table Facet.\nCheck Settings(Quick start) for snippets of Settings.\nInstallation Maven pom.xml \u003crepositories\u003e \u003crepository\u003e \u003cid\u003efoxglove-repo\u003c/id\u003e \u003cname\u003eFoxglove Maven Repository\u003c/name\u003e \u003curl\u003ehttps://maven.pkg.github.com/mikelue/foxglove\u003c/url\u003e \u003csnapshots\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003c/snapshots\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003cdependency\u003e \u003cgroupId\u003eguru.mikelue.foxglove\u003c/groupId\u003e \u003cartifactId\u003ecore\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e GitHub Maven registry authentication($HOME/.m2/settings.xml) \u003cservers\u003e \u003cserver\u003e \u003cid\u003efoxglove-repo\u003c/id\u003e \u003cusername\u003emikelue\u003c/username\u003e \u003cpassword\u003eyour_token\u003c/password\u003e \u003c/server\u003e \u003c/servers\u003e Don’t forget to create a PAT(personal access token) on GitHub.\nWoking with Maven registry(GitHub)\nGradle repositories { maven { name 'foxglove-repo' url 'https://maven.pkg.github.com/mikelue/foxglove' } } testImplementation 'guru.mikelue.foxglove:core:1.0-SNAPSHOT' SBT resolvers += \"foxglove-repo\" at \"https://maven.pkg.github.com/mikelue/foxglove\" libraryDependencies += \"guru.mikelue.foxglove\" % \"core\" % \"1.0-SNAPSHOT\" % Test ivysettings.xml \u003civysettings\u003e \u003csettings defaultResolver=\"chain\"/\u003e \u003cresolvers\u003e \u003cchain name=\"chain\"\u003e \u003cibiblio name=\"foxglove-repo\" m2compatible=\"true\" root=\"https://maven.pkg.github.com/mikelue/foxglove\" pattern=\"[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier]).[ext]\"/\u003e \u003c/chain\u003e \u003c/resolvers\u003e \u003c/ivysettings\u003e Ivy \u003cdependency org=\"guru.mikelue.foxglove\" name=\"core\" rev=\"1.0-SNAPSHOT\" conf=\"test\"/\u003e Use DataSource Generating data by javax.sql.DataSource import javax.sql.DataSource; import guru.mikelue.foxglove.jdbc.JdbcTableFacet; import guru.mikelue.foxglove.jdbc.JdbcDataGenerator; // Generates 4 rows with \"cr_brand \"fixed to \"Toyota\" and // 4 different values on \"cr_model\" var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(4) .column(\"cr_brand\") .fixed(\"Toyota\") .column(\"cr_model\") .roundRobin(\"Corolla\", \"Camry\", \"RAV4\", \"Prius\") .build(); new JdbcDataGenerator(getDataSource()) .generate(facet); See default generators page for more details.\nReferences DataSource\nTable Facet - Defines logics for generating data for a specific table.\nSettings - Defines logics for generating data by data type, etc.",
    "description": "The index page for articles to get started quickly.",
    "tags": [],
    "title": "Quick-start",
    "uri": "/quickstart/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Quick-start",
    "content": "A table facet is the rules about rows to be generated for a database table.\nUse JdbcTableFacet.builder() to define a table facet.\nThe default number of rows is 1024.\nJava package: guru.mikelue.foxglove.jdbc\nSetting Use DataSetting on table var setting = new DataSetting() // Excludes any column with JDBCType of OTHER .excludeWhen(columnMeta -\u003e columnMeta.jdbcType() == JDBCType.OTHER) // For any column with type of \"VARCHAR\", using the supplier .givenType(JDBCType.VARCHAR) .useSupplier(() -\u003e sampleText + suffixSupplier.get()) // For not-nullable SMALLINT columns, generating values between 2010 and 2020 .columnMatcher( columnMeta -\u003e columnMeta.jdbcType() == JDBCType.SMALLINT \u0026\u0026 !columnMeta.properties().contains(Property.NULLABLE) ) .useSupplier(gen().shorts().range((short)2010, (short)2020)::get); var facet = JdbcTableFacet.builder(TABLE_CAR) // Uses the setting on the whole table .withSetting(setting) .numberOfRows(RANDOM_SIZE) .build(); Set number of rows Fixed number of rows var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .build(); Bound range of a key column // The range of cr_id is between 1000 and 1000 + RANDOM_SIZE - 1 var facet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").limit(1000, RANDOM_SIZE) .build(); Cartesian product across columns // Generates 3 (brands) * 3 (years) = 9 rows var facet = JdbcTableFacet.builder(TABLE_CAR) .cartesianProduct(\"cr_brand\") .domain(\"Toyota\", \"Honda\", \"Ford\") .cartesianProduct(\"cr_year\") .domain(2020, 2021, 2022) .build(); Column generators Fixed value var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_color\").fixed(sampleColor) .build(); Custom random values // Generates random year between 2015 and 2025 var yearSupplier = gen().ints().range(2015, 2025); var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_year\").useSupplier(yearSupplier) .build(); Round robin values // Round robin among BMW, Audi, and Mercedes var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_brand\") .roundRobin(\"BMW\", \"Audi\", \"Mercedes\") .build(); Sequence number // Generates license plate like CAR-01, CAR-02, ... var sequence = new Int4SequenceSupplier(2, 2); Supplier\u003cString\u003e plateSupplier = () -\u003e String.format( \"CAR-%02d\", sequence.getAsInt() ); var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_license_plate\").useSupplier(plateSupplier) .build(); Null value(Instancio) // Generates colors(red, blue, green, or NULL) and 1/6 odds to be null var colorSupplier = gen().oneOf(\"red\", \"blue\", \"green\") .nullable(); var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(ROWS) .column(\"cr_color\").useSupplier(colorSupplier) .build(); Null value(customize odds) // Generates colors(red, blue, green, or NULL) and 50% chance to be null var colorSupplier = Suppliers.rollingSupplier( gen().oneOf(\"red\", \"blue\", \"green\"), 2 ); var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(ROWS) .column(\"cr_color\").useSupplier(colorSupplier) .build(); Referencing another table Referencing(control number of rows) // Prepares parent facet var carFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .build(); // Generates rows referencing to the parent facet. // The number of features is equal to \"RANDOM_SIZE\". var featureFacet = JdbcTableFacet.builder(TABLE_CAR_FEATURE) .referencing(\"cf_cr_id\").parent(carFacet, \"cr_id\") // Every car is referenced by one feature. .cardinality(1) .column(\"cf_feature_name\") .fixed(\"Sunroof\") .build(); Use values of another table as domain // Prepares parent facet var carFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_color\") .roundRobin(\"Red\", \"Blue\", \"Green\") .build(); var carArchivedFacet = JdbcTableFacet.builder(TABLE_CAR_ARCHIVED) .numberOfRows(10) // Has no effect on the number of rows .column(\"ca_color\") .from(carFacet, \"cr_color\") // Chooses the values of cars' colors randomly .random() .build(); See Many-to-Many relationship for more examples about referencing another table.\nAfter generation hook Change generated rows var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_brand\") .roundRobin(\"Toyota\", \"Honda\", \"Ford\", \"BMW\", \"Audi\") // Sets the value of \"cr_license_plate\" by combination of \"cr_brand\" and a random number .onTupleGenerated(tuple -\u003e tuple.setValue( \"cr_license_plate\", tuple.getValue(\"cr_brand\") + \"-\" + randomNumber.get() )) .build(); References Table Facet - Defines logics for generating data for a specific table.\nSettings - Defines logics for generating data by data type, etc.\nInstancioGenApi - For generating random values.",
    "description": "Quick start to define a table facet",
    "tags": [],
    "title": "Table Facet",
    "uri": "/quickstart/table-facet/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Docs",
    "content": "Overview Inspired by selector of Instancing, {floxglove-link} provides several ways to specify the mapping between columns and generators for TableFacet.\nJdbcTableFacet.Builder is the entry point to define value generators on columns of a table.\nPackages:\nguru.mikelue.foxglove.jdbc - The main package providing JdbcDataGenerator and JdbcTableFacet.\nCode convention:\ngen() - an instance of InstancioGenApi.\nVersatile example of builder var randomNumber = gen().ints().range(1000, 9999); var setting = new DataSetting() // Generates past date-time or JDBCType of \"TIMESTAMP_WITH_TIMEZONE .givenType(JDBCType.TIMESTAMP_WITH_TIMEZONE) .useSupplier( gen().temporal().zonedDateTime() .past() ) // Customizes text pattern for any column with \"model\" in its name .columnMatcher( columnMeta -\u003e columnMeta.name().contains(\"model\") ) .useSupplier(gen().text().pattern(\"Model-#C#C#d#d\")); var facet = JdbcTableFacet.builder(TABLE_CAR) // Uses the setting on this table .withSetting(setting) .numberOfRows(RANDOM_SIZE) // Round robin among several brands .column(\"cr_brand\") .roundRobin(\"Toyota\", \"Honda\", \"Ford\", \"BMW\", \"Audi\") // Generates year between 2015 and 2025 .column(\"cr_year\") .useSpec(() -\u003e gen().shorts().range((short)2015, (short)2025)) // Random choice for number of seats .column(\"cr_seats\") .useSpec(() -\u003e gen().oneOf(2, 4, 5, 7)) // Color with nullable property get nullable values .\u003cString\u003ecolumn(\"cr_color\") .decideSupplier(columnMeta -\u003e { var colorGenerator = gen().oneOf(\"Red\", \"Blue\", \"Green\"); if (columnMeta.properties().contains(Property.NULLABLE)) { return colorGenerator.nullable(); } return colorGenerator; }) // Fixed value for status column .column(\"cr_status\") .fixed(null) // Includes these two columns by auto-generating their values .includeColumns(\"cr_license_plate\", \"cr_daily_rate\", \"cr_created_at\", \"cr_model\") // Alter the values for \"cr_license_plate\" and \"cr_daily_rate\" .onTupleGenerated(tuple -\u003e { tuple.setValue( \"cr_license_plate\", tuple.getValue(\"cr_brand\") + \"-\" + randomNumber.get() ); var dailyRate = switch (tuple.\u003cString\u003egetValue(\"cr_brand\")) { case \"Toyota\", \"Honda\" -\u003e 0.01; case \"Ford\" -\u003e 0.02; default -\u003e 0.03; }; tuple.setValue(\"cr_daily_rate\", dailyRate); }) .build(); Value generators The way to choose which columns to be applied:\nUse Builder.column(String) to specify a column by name and set up value generator.\nBy DataSetting, you can use java.sql.JDBCType, type name, or ColumnMatcher(a Predicate for ColumnMeta) for choosing columns.\nNote You could use DataGenerator.withSetting(DataSetting) that change the way to choose Supplier automatically. See Settings for more details about DataSetting.\nA value generator can be:\nAn instance of Supplier - by useSupplier(Supplier\u003cT\u003e)\nA Function - turns a ColumnMeta to a {Supplier} - by decideSupplier(SupplierDecider\u003cT\u003e)\nA Supplier of ValueSpec - by useValueSpec(Supplier\u003cValueSpce\u003cT\u003e\u003e)\nA RowIndexToValue(as Function) - turns row indexes to values - by forRow(RowIndexToValue\u003cT\u003e)\nNote You can use InstancioGenApi (providing bunch of ValueSpecs) to create Supplier for any kind of random data. By predicate of column Use Builder.withSetting(DataSetting) to specify a generator by java.sql.JDBCType, type name, or ColumnMatcher(a Predicate for ColumnMeta).\nPredicate example var setting = new DataSetting() // Excludes any column with JDBCType of OTHER .excludeWhen(columnMeta -\u003e columnMeta.jdbcType() == JDBCType.OTHER) // For any column with type of \"VARCHAR\", using the supplier .givenType(JDBCType.VARCHAR) .useSupplier(() -\u003e sampleText + suffixSupplier.get()) // For not-nullable SMALLINT columns, generating values between 2010 and 2020 .columnMatcher( columnMeta -\u003e columnMeta.jdbcType() == JDBCType.SMALLINT \u0026\u0026 !columnMeta.properties().contains(Property.NULLABLE) ) .useSupplier(gen().shorts().range((short)2010, (short)2020)::get); var facet = JdbcTableFacet.builder(TABLE_CAR) // Uses the setting on the whole table .withSetting(setting) .numberOfRows(RANDOM_SIZE) .build(); Include/Exclude columns Except specifying columns one by one by Builder.column(String), following methods filter columns to be included/excluded for data generation automatically:\nBuilder.includeColumns(String…​) - Only these columns will to be generated automatically(DataSetting), whatever the properties(e.g. Generated Columns(PostgreSQL)) they have.\nJdbcDataGenerator would throw error if no supplier can be found.\nIf you would like to use default value defined by DDL, don’t put the column name in this list.\nBuilder.excludeColumns(String…​) - columns must not to be generated automatically.\nUndefined columns are decided by DataSetting. This logic is differ from includeColumns().\nIf you would like to use default value defined by DDL, put the column name in this list.\nAbove two methods are mutually exclusive.\nInclude columns var tableFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) // Must put all of the columns which are not-nullable, no-default value. .includeColumns(\"cr_license_plate\", \"cr_brand\", \"cr_model\", \"cr_year\") .build(); Exclude columns var tableFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) // These columns would not be generated by Foxglove .excludeColumns(\"cr_seats\", \"cr_color\", \"cr_status\", \"cr_created_at\", \"cr_updated_at\") .build(); The number of rows You can only use one of the following ways to specify the number of rows for a table:\nUse Builder.numberOfRows(int) to set a fixed number of rows.\nUse Builder.keyOfInt(String) to set a key column, which must be integral type(INT, BIGINT, etc).\nUse Builder.cartesianProduct(String) to set up domain for columns(at least one)\nUse Builder.referencing(String) to set up referencing to another table’s column.\nNote If you would like to use domain of fixed values but the column is not integral type. There are ways to achieve that:\nDefine normal column // Prepares list of colors var colors = gen().oneOf(\"Red\", \"Blue\", \"Green\") .list(RANDOM_SIZE); var facet = JdbcTableFacet.builder(TABLE_CAR) // The number of rows is equal to the size of colors list .numberOfRows(colors.size()) // Use round robin for these colors .column(\"cr_color\").roundRobin(colors) .build(); Cartesian product on only one column // Prepares list of colors var colors = gen().oneOf(\"Red\", \"Blue\", \"Green\") .list(RANDOM_SIZE); var facet = JdbcTableFacet.builder(TABLE_CAR) // Use round robin for these colors .cartesianProduct(\"cr_color\").domain(colors) .build(); Fix number of rows Fixed number of rows var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .build(); Key range When using keyOfInt(String), you can specify the range of key values by:\nrange(start, end) - With start(inclusive) number and end(exclusive) number.\nlimit(long, int) - With start(inclusive) number and fixed number of rows.\nKey column // The range of cr_id is between 1000 and 1000 + RANDOM_SIZE - 1 var facet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").limit(1000, RANDOM_SIZE) .build(); Note You can only use one column as key column. The keyOfInt(String) is not about uniqueness, is about defining the number of rows.\nHowever, the database is likely having uniqueness constraint on the column.\nCartesian product of columns Cartesian product // Generates 3 (brands) * 3 (years) = 9 rows var facet = JdbcTableFacet.builder(TABLE_CAR) .cartesianProduct(\"cr_brand\") .domain(\"Toyota\", \"Honda\", \"Ford\") .cartesianProduct(\"cr_year\") .domain(2020, 2021, 2022) .build(); Cartesian product by referencing // Any way to generate data for these two tables var carFacet = JdbcTableFacet.builder(TABLE_CAR) .keyOfInt(\"cr_id\").limit(1000, 3) .build(); var memberFacet = JdbcTableFacet.builder(TABLE_MEMBER) .keyOfInt(\"mb_id\").limit(2000, 5) .build(); // :~) var rentFacet = JdbcTableFacet.builder(TABLE_RENT) // References to ids of cars .cartesianProduct(\"rt_cr_id\") .referencing(carFacet, \"cr_id\") // References to ids of members .cartesianProduct(\"rt_mb_id\") .referencing(memberFacet, \"mb_id\") .build(); Referencing to another table Only one column can be used for referencing.\nReferencing column\n// Prepares parent facet var carFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .build(); // Generates rows referencing to the parent facet. // The number of features is equal to \"RANDOM_SIZE\". var featureFacet = JdbcTableFacet.builder(TABLE_CAR_FEATURE) .referencing(\"cf_cr_id\").parent(carFacet, \"cr_id\") // Every car is referenced by one feature. .cardinality(1) .column(\"cf_feature_name\") .fixed(\"Sunroof\") .build(); You can use .column(String).from(JdbcTableFacet, String) to uses values of another table’s column as domain.\nSee Other generators section for using values of another table’s column as domain values.\nSequence number You can use Int4SequenceSupplier or Int8SequenceSupplier to define sequence number on a column.\nSequence number generator // Generates license plate like CAR-01, CAR-02, ... var sequence = new Int4SequenceSupplier(2, 2); Supplier\u003cString\u003e plateSupplier = () -\u003e String.format( \"CAR-%02d\", sequence.getAsInt() ); var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_license_plate\").useSupplier(plateSupplier) .build(); Other kinds of value generator fix(value) - Use a fixed value on the column.\nroundRobin(…​) - Round robin provided value on the column.\nfrom(JdbcTableFacet, String) - Copy values from another table’s column.\nYou can combine with other generator(e.g. roundRobin(), random()) to control how to pick value from source column.\nFrom values of column of another table // Prepares parent facet var carFacet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_color\") .roundRobin(\"Red\", \"Blue\", \"Green\") .build(); var carArchivedFacet = JdbcTableFacet.builder(TABLE_CAR_ARCHIVED) .numberOfRows(10) // Has no effect on the number of rows .column(\"ca_color\") .from(carFacet, \"cr_color\") // Chooses the values of cars' colors randomly .random() .build(); Change row values After a row get generated, which is type of TupleAccessor object, you can change the row by Builder.onTupleGenerated(Consumer\u003cRowAccessor\u003e).\nNote Only values of included columns can be changed. Modifying row var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(RANDOM_SIZE) .column(\"cr_brand\") .roundRobin(\"Toyota\", \"Honda\", \"Ford\", \"BMW\", \"Audi\") // Sets the value of \"cr_license_plate\" by combination of \"cr_brand\" and a random number .onTupleGenerated(tuple -\u003e tuple.setValue( \"cr_license_plate\", tuple.getValue(\"cr_brand\") + \"-\" + randomNumber.get() )) .build(); References:\nSettings - for more details about DataSetting\nDefault Generators - for default generators",
    "description": "Usage of TableFacet to control data generation for a table",
    "tags": [],
    "title": "Table Facet",
    "uri": "/docs/table-facet/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "Core objects Table Facet - Defines logics for generating data for a specific table.\nSettings - Defines fallback generators by matching type of a column or customizing rules.\nDefault Generators - Default rules defined by default DataSetting.\nCore packages Java package: guru.mikelue.foxglove\nDataGenerator - the abstract interface defining the operation to database.\nTableFacet - the abstract interface defining basic information of a table.\nColumnMeta - The read-only object of columns' metadata.\nJava package: guru.mikelue.foxglove.jdbc\nJdbcDataGenerator - The main service class processing JdbcTableFacet by using DataSource(or Connection)\nJdbcTableFacet - the main type providing an intance of TableFacet.\nJdbcTableFacet.builder(String) - The builder for a JdbcTableFacet instance.\nJava package: guru.mikelue.foxglove.setting\nDataSetting - The main object for fallback setting used by DataGenerator and TableFacet.\nJava package: guru.mikelue.foxglove.functional\nInt4SequenceSupplier, Int8SequenceSupplier - The built-in sequence suppliers for integral sequence numbers.\nRoundRobinValueSupplier - The built-in round-robin value supplier.\nColumnMatcher - The predicate interface to match ColumnMeta.\nMostly used with JdbcTableFacet.Builder or DataSetting\nSupplierDecider - The functional interface to decide a Supplier by a ColumnMeta.\nMostly used with JdbcTableFacet.Builder or DataSetting",
    "description": "Core objects Table Facet - Defines logics for generating data for a specific table.\nSettings - Defines fallback generators by matching type of a column or customizing rules.\nDefault Generators - Default rules defined by default DataSetting.\nCore packages Java package: guru.mikelue.foxglove\nDataGenerator - the abstract interface defining the operation to database.\nTableFacet - the abstract interface defining basic information of a table.\nColumnMeta - The read-only object of columns' metadata.",
    "tags": [],
    "title": "Docs",
    "uri": "/docs/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Docs",
    "content": "See default generators page for more details about default generators.\nPackages:\nguru.mikelue.foxglove.setting - The main package providing DataSetting.\nOverview The setting object is DataSetting, which controls how to decide generators for columns.\nWays to choose generators(ordered by priority) By ColumnMatcher, which is a Predicate\u003cColumnMeta\u003e\nBy type name(as String), which comes from TYPE_NAME of DatabaseMetaData.getColumns(…​)\nBy java.sql.JDBCType, which comes from DATA_TYPE of DatabaseMetaData.getColumns(…​)\nWays to provide Supplier for a column A Supplier\nA SupplierDecider, which is a function to decide Supplier by ColumnMeta\nA Supplier for ValueSpec of Instancio\nVersatile example of DataSetting new DataSetting() // Generates 20 rows if no other row number setting on the table .setDefaultNumberOfRows(20) // Excludes columns with name starting with \"audit_\" .excludeWhen(columnMeta -\u003e columnMeta.name().startsWith(\"audit_\")) // Use column matcher .columnMatcher(columnMeta -\u003e columnMeta.name().endsWith(\"_status\")) // Choose one of the fixed domain values randomly .useSupplier(gen().oneOf(\"ACTIVE\", \"INACTIVE\", \"PENDING\")) // For type name .givenType(\"enum_status\") // Choose one of the fixed domain values randomly .useSupplier(gen().oneOf(\"ACTIVE\", \"INACTIVE\", \"UNKNOWN\")) // For JDBCType .givenType(JDBCType.VARCHAR) // Fixed value for all VARCHAR columns .useSupplier(() -\u003e \"fixed-text\") .givenType(JDBCType.INTEGER) // Fixed range for all INTEGER columns .useSpec(() -\u003e gen().ints().range(1000, 1000000)) // Generates 128 characters for types of TEXT, LONGVARCHAR, etc. .largeTextLength(128) // Generates null values with 5% odds for all nullable columns .generateNull(20); Global settings You could use DataSetting.default() to get the current global settings.\nModify global settings DataSetting.defaults() // Generates text with 128 characters for types of TEXT, LONGVARCHAR, etc. .largeTextLength(128) // Generates null values with 10% odds for all nullable columns .generateNull(10); Apply to TableFacet See Table Facet - Setting for applying DataSetting to TableFacet.\nApply to DataGenerator DataGenerator.withSetting var dataSetting = new DataSetting() // Wont' generate value for NULLABLE column automatically .notAutoGenerateFor(Property.NULLABLE); var dataGenerator = new JdbcDataGenerator(getDataSource()); dataGenerator .withSetting(dataSetting); Multi-level settings Both of TableFacet and DataGenerator are implementing SettingAware, which have their own settings.\nThe priority of settings(from high to low) are:\nTableFacet setting\nDataGenerator setting\nDataSetting.defaults()\nNote The scalar settings(e.g. generateNull(boolean), largeTextLength(int)) are only applied to current level.\nIf current level have found(by resolveSupplier(ColumnMeta)) a Supplier for a column, it will use these scalar settings from itself.\nExcluding The DataSetting is a kind of fallback mechanism to provide generators for columns without specific generator defined.\nYou could use DataSetting.execludeWhen(Predicate\u003cColumnMeta\u003e) to exclude some columns from applying any generator of this setting.\nExcluding example var dataSetting = new DataSetting() // Excludes the column with name ending with \"_computed\" .excludeWhen(meta -\u003e meta.name().endsWith(\"_computed\")); References java.sql.JDBCType\nDatabaseMetaData.getColumns(…​)\nResultSetMetaData",
    "description": "Different level of settings to control data generation",
    "tags": [],
    "title": "Settings",
    "uri": "/docs/settings/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Quick-start",
    "content": "Note the configuration in JdbcTableFacet takes precedence over the global setting. Java package: guru.mikelue.foxglove.setting\nA setting controls the fallback behavior of data generation.\nSetting on table facet See: Table Facet - Setting\nSetting on DataGenerator Use DataSetting on DataGenerator var dataSetting = new DataSetting() // Wont' generate value for NULLABLE column automatically .notAutoGenerateFor(Property.NULLABLE); var dataGenerator = new JdbcDataGenerator(getDataSource()); dataGenerator .withSetting(dataSetting); Global setting Change setting globally DataSetting.defaults() // Generates text with 128 characters for types of TEXT, LONGVARCHAR, etc. .largeTextLength(128) // Generates null values with 10% odds for all nullable columns .generateNull(10); Configurations Suppliers by rules Note see DatabaseMetaData.getColumns(…​) for detail of metadata. By JDBCType var dataSetting = new DataSetting() // Sets up fixed text for all VARCHAR columns .givenType(JDBCType.VARCHAR) .useSupplier(() -\u003e \"fixed-text\"); By type name var dataSetting = new DataSetting() // Sets up fixed text for columns with type name of \"VARYING CHARACTERS\" .givenType(\"VARYING CHARACTERS\") .useSupplier(() -\u003e \"varying-text\"); By column matcher var dataSetting = new DataSetting() // Sets up supplier if the name of column contains \"address\" .columnMatcher(meta -\u003e meta.name().contains(\"address\")) .useSupplier(addressGen); Auto-generating behavior By column’s properties var dataSetting = new DataSetting() // Generates value even if the column is AUTO_INCREMENT .autoGenerateFor(Property.AUTO_INCREMENT) // Won't generate value for NULLABLE columns .notAutoGenerateFor(Property.NULLABLE); By condition of exclusion var dataSetting = new DataSetting() // Excludes the column with name ending with \"_computed\" .excludeWhen(meta -\u003e meta.name().endsWith(\"_computed\")); Generating null values The control the generation of null values on NULLABLE COLUMNS.\nDefault dicing for nullable value var dataSetting = new DataSetting() .givenType(JDBCType.VARCHAR) .useSupplier(() -\u003e \"not-null-value\") // Generates null value(1/6 odds) for any nullable column .generateNull(true); Customize odds for nullable value var dataSetting = new DataSetting() .givenType(JDBCType.VARCHAR) .useSupplier(() -\u003e \"not-null-value\") // Generates null value(10% odds) for any nullable column .generateNull(10); Misc Sets the length for large text var dataSetting = new DataSetting() // Generates 256 characters for types of TEXT, LONGVARCHAR, etc. .largeTextLength(256); References JDBCType\nSettings - Complete guideline for DataSetting.\nInstancioGenApi - For generating random values.",
    "description": "Quick start to use DataSetting",
    "tags": [],
    "title": "Settings",
    "uri": "/quickstart/settings/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Docs",
    "content": "Foxglove provides default generators based on columns' metadata.\nSee Default spec by JDBC Type for more details.\nGlobal setting You can get the global setting by DataSetting.default().\nThe DataSetting provides various methods to change how values are generated for columns.\nSee Settings for more details.\nDefault behavior by DDL DDL provides some definitions about the columns, Foxglove's default behavior over column definitions are(sorted by priority):\nGenerated(FALSE) - Won’t generate values\nAuto Increament(FALSE) - Won’t generate values\nNullable(TRUE) - Generate viable(random) values\nDefault value(TRUE) - Generate viable(random) values\nAny column has any of above properties will follow the TRUE/FALSE to decide whether or not to generate the value automatically.\nIf a column has none of above properties, Foxglove will generate viable(random) values for it.\nYou can change the behavior by DataSetting.autoGenerateFor() and DataSetting.notAutoGenerateFor().\nFor nullable column, you can generate possible NULL value by setting DataSetting.generateNull(true) or ValueSpec's nullable() method.\nNote These properties are ignored if a TableFacet define its own logic for a matched column. See DataSetting of javadoc for more details.\nDefault number of rows Note The default number of rows(to be generated) is 1024. Use DataSetting.setDefaultNumberOfRows(int) to change the it.\nDefault spec by JDBC Type Depends on java.sql.JDBCType, Foxglove provides default generators for:\nFor integral data The min value of integral types would be equals to 0.\nJDBC Type\nDefault Generator\nBIT, BOOLEAN\nBooleanSpec\nTINYINT\nByteSpec\nSMALLINT\nShortSpec\nINTEGER\nIntegerSpec\nBIGINT\nLongSpec\nFor floating point data JDBC Type\nDefault Generator\nFLOAT, REAL\nFloatSpec\nMin value would be equals to 0.0f.\nDOUBLE\nDoubleSpec\nMin value would be equals to 0.0f.\nNUMERIC, DECIMAL\nBigDecimalSpec\nFor BigDecimalSpec, the precision would be equals to ColumnMeta.size(), ColumnMeta.decimalDigits().\nTODO: PostgreSQL supports negative value of scale for NUMERIC(4, -3), which should be implemented specifically.\nSpecial note of PostgreSQL PostgreSQL permits the scale in a numeric type declaration to be any value in the range -1000 to 1000. However, the SQL standard requires the scale to be in the range 0 to precision. Using scales outside that range may not be portable to other database systems.\nSee PostgreSQL Numeric Types for more details.\nFor text data By default, all of characters type are generated by alphaNumeric() of StringGeneratorSpec.\nFor CHAR, VARCHAR, NCHAR, NVARCHAR ColumnMeta.size()\nValueGenerator\n⇐ 8(less than or equal to 8)\nSame as ColumnMeta.size()\n\u003e 8 \u0026\u0026 ⇐ 32(between 8 and 32)\nLength is between 8 and ColumnMeta.size()\n\u003e 32(more than 32)\nLength is between 32 and Math.min(ColumnMeta.size(), 128)\nFor LONGVARCHAR, CLOB, LONGNVARCHAR, NCLOB Generate text with length between 1024 and 2048.\nCustomization of large text:\nUse DataSetting.largeTextLength(minLength, maxLength) to change the random length for large text columns.\nFor date/time/timestamp JDBC Type\nDefault Generator\nDATE\nLocalDateSpec\nTIME\nLocalTimeSpec\nTIMESTAMP\nLocalDateTimeSpec\nTIME_WITH_TIMEZONE\nOffsetTimeSpec\nTIMESTAMP_WITH_TIMEZONE\nZonedDateTimeSpec\nFor binary data By default, all of binary type are generated by ByteSpec.\nFor BINARY, VARBINARY ColumnMeta.size()\nValueGenerator\n⇐ 16(less than or equal to 16). UUID is 16 bytes.\nSame as ColumnMeta.size()\n\u003e 16 \u0026\u0026 ⇐ 64(between 16 and 64)\nLength is between 16 and ColumnMeta.size()\n\u003e 64(more than 64)\nLength is between 64 and Math.min(ColumnMeta.size(), 256)\nFor LONGVARBINARY, BLOB Generate binary with length between 1024 and 2048.\nSpecial types By type name UUID - UUIDSpec\nNot supported JDBCTypes ARRAY, STRUCT\nTODO: Oracle, PostgreSQL support array/struct types.\nROWID, NULL, JAVA_OBJECT, DISTINCT, OTHER\nSQLXML - Won’t generate values\nTODO: Oracle, PostgreSQL, SQL Server support array/struct types.\nREF, REF_CURSOR, DATALINK",
    "description": "Default generator for various types of columns",
    "tags": [],
    "title": "Default Generators",
    "uri": "/docs/default-generators/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "The examples in this section with following database schema(see SampleSchema.java):\nCREATE TABLE ap_car ( cr_id BIGINT PRIMARY KEY AUTO_INCREMENT, cr_license_plate VARCHAR(20) NOT NULL UNIQUE, cr_brand VARCHAR(50) NOT NULL, cr_model VARCHAR(50) NOT NULL, cr_year SMALLINT NOT NULL, cr_seats TINYINT NOT NULL DEFAULT 4, cr_daily_rate DECIMAL(4,2), cr_color VARCHAR(30), cr_full_name VARCHAR(128) GENERATED ALWAYS AS CONCAT(cr_brand, '-', cr_model, '-', cr_year), cr_status ENUM('available', 'rented', 'maintenance') DEFAULT 'available', cr_dimensions INTEGER ARRAY[4], cr_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, cr_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL ); CREATE INDEX ix_ap_car__cr_model ON ap_car(cr_model); CREATE INDEX ix_ap_car__cr_color ON ap_car(cr_color); CREATE TABLe ap_car_feature ( cf_cr_id BIGINT NOT NULL CONSTRAINT fk_ap_car_feature__ap_car REFERENCES ap_car(cr_id) ON DELETE CASCADE ON UPDATE RESTRICT, cf_feature_name VARCHAR(32) NOT NULL, CONSTRAINT pk_ap_car_feature PRIMARY KEY(cf_cr_id, cf_feature_name), CONSTRAINT unq_ap_car_feature__cf_cr_id_cf_feature_name UNIQUE(cf_cr_id, cf_feature_name) ); CREATE TABLE ap_member ( mb_id BIGINT PRIMARY KEY AUTO_INCREMENT, mb_first_name VARCHAR(50) NOT NULL, mb_last_name VARCHAR(50) NOT NULL, mb_email VARCHAR(100) NOT NULL, mb_license_number VARCHAR(50) NOT NULL UNIQUE, mb_phone VARCHAR(20), mb_address TEXT, mb_status ENUM('active', 'suspended', 'inactive') DEFAULT 'active', mb_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, mb_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL ); CREATE INDEX ix_ap_member__mb_first_name_mb_last_name ON ap_member(mb_first_name, mb_last_name); CREATE TABLE ap_rent ( rt_id UUID DEFAULT RANDOM_UUID() PRIMARY KEY, rt_cr_id BIGINT NOT NULL CONSTRAINT fk_ap_rent__ap_car REFERENCES ap_car(cr_id) ON DELETE RESTRICT ON UPDATE RESTRICT, rt_mb_id BIGINT NOT NULL CONSTRAINT fk_ap_rent__ap_member REFERENCES ap_member(mb_id) ON DELETE RESTRICT ON UPDATE RESTRICT, rt_start_date TIMESTAMP WITH TIME ZONE NOT NULL, rt_end_date TIMESTAMP WITH TIME ZONE, rt_total_amount DECIMAL(10,2), rt_status ENUM('active', 'completed', 'cancelled') DEFAULT 'active', rt_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, rt_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL, CONSTRAINT unq_ap_rent__rt_cr_id_rt_mb_id_rt_start_date UNIQUE(rt_mb_id, rt_cr_id, rt_start_date) ); CREATE INDEX ix_ap_rent__rt_mb_id ON ap_rent(rt_mb_id); CREATE TABLE ap_car_archived ( ca_id BIGINT PRIMARY KEY AUTO_INCREMENT, ca_license_plate VARCHAR(20) NOT NULL UNIQUE, ca_brand VARCHAR(50) NOT NULL, ca_model VARCHAR(50) NOT NULL, ca_year SMALLINT NOT NULL, ca_seats TINYINT NOT NULL DEFAULT 4, ca_color VARCHAR(30), ca_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL );",
    "description": "The examples in this section with following database schema(see SampleSchema.java):\nCREATE TABLE ap_car ( cr_id BIGINT PRIMARY KEY AUTO_INCREMENT, cr_license_plate VARCHAR(20) NOT NULL UNIQUE, cr_brand VARCHAR(50) NOT NULL, cr_model VARCHAR(50) NOT NULL, cr_year SMALLINT NOT NULL, cr_seats TINYINT NOT NULL DEFAULT 4, cr_daily_rate DECIMAL(4,2), cr_color VARCHAR(30), cr_full_name VARCHAR(128) GENERATED ALWAYS AS CONCAT(cr_brand, '-', cr_model, '-', cr_year), cr_status ENUM('available', 'rented', 'maintenance') DEFAULT 'available', cr_dimensions INTEGER ARRAY[4], cr_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, cr_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL ); CREATE INDEX ix_ap_car__cr_model ON ap_car(cr_model); CREATE INDEX ix_ap_car__cr_color ON ap_car(cr_color); CREATE TABLe ap_car_feature ( cf_cr_id BIGINT NOT NULL CONSTRAINT fk_ap_car_feature__ap_car REFERENCES ap_car(cr_id) ON DELETE CASCADE ON UPDATE RESTRICT, cf_feature_name VARCHAR(32) NOT NULL, CONSTRAINT pk_ap_car_feature PRIMARY KEY(cf_cr_id, cf_feature_name), CONSTRAINT unq_ap_car_feature__cf_cr_id_cf_feature_name UNIQUE(cf_cr_id, cf_feature_name) ); CREATE TABLE ap_member ( mb_id BIGINT PRIMARY KEY AUTO_INCREMENT, mb_first_name VARCHAR(50) NOT NULL, mb_last_name VARCHAR(50) NOT NULL, mb_email VARCHAR(100) NOT NULL, mb_license_number VARCHAR(50) NOT NULL UNIQUE, mb_phone VARCHAR(20), mb_address TEXT, mb_status ENUM('active', 'suspended', 'inactive') DEFAULT 'active', mb_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, mb_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL ); CREATE INDEX ix_ap_member__mb_first_name_mb_last_name ON ap_member(mb_first_name, mb_last_name); CREATE TABLE ap_rent ( rt_id UUID DEFAULT RANDOM_UUID() PRIMARY KEY, rt_cr_id BIGINT NOT NULL CONSTRAINT fk_ap_rent__ap_car REFERENCES ap_car(cr_id) ON DELETE RESTRICT ON UPDATE RESTRICT, rt_mb_id BIGINT NOT NULL CONSTRAINT fk_ap_rent__ap_member REFERENCES ap_member(mb_id) ON DELETE RESTRICT ON UPDATE RESTRICT, rt_start_date TIMESTAMP WITH TIME ZONE NOT NULL, rt_end_date TIMESTAMP WITH TIME ZONE, rt_total_amount DECIMAL(10,2), rt_status ENUM('active', 'completed', 'cancelled') DEFAULT 'active', rt_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL, rt_updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL, CONSTRAINT unq_ap_rent__rt_cr_id_rt_mb_id_rt_start_date UNIQUE(rt_mb_id, rt_cr_id, rt_start_date) ); CREATE INDEX ix_ap_rent__rt_mb_id ON ap_rent(rt_mb_id); CREATE TABLE ap_car_archived ( ca_id BIGINT PRIMARY KEY AUTO_INCREMENT, ca_license_plate VARCHAR(20) NOT NULL UNIQUE, ca_brand VARCHAR(50) NOT NULL, ca_model VARCHAR(50) NOT NULL, ca_year SMALLINT NOT NULL, ca_seats TINYINT NOT NULL DEFAULT 4, ca_color VARCHAR(30), ca_created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL );",
    "tags": [],
    "title": "Examples",
    "uri": "/examples/index.html"
  },
  {
    "breadcrumb": "Introduction \u003e Docs",
    "content": "Transaction The insertions of generated data would be collected into batches bound by transactions.\nJdbcDataGenerator.setBatchSize(int) decides the batch size for a transaction.\nThe default batch size is 1024.\nTests on databases/JDBC drivers Table 1. Tested Databases and JDBC Drivers Database System\nJDBC Driver\nNote\nH2 Database Engine\ncom.h2database:h2 (2.4.240)\nmode is regular, by local file\nHyperSQL\norg.hsqldb:hsqldb (2.7.4)\nby local file\nApache Derby\norg.apache.derby:derby (10.17.1.0)\nby local file\nSqlite(xerial/sqlite-jdbc)\norg.xerial:sqlite-jdbc (3.42.0.0)\nby local file\nPostgreSQL 16\norg.postgresql:postgresql (42.7.8)\nMySQL 8.4\ncom.mysql:mysql-connector-j (9.5.0)\nMicrosoft SQL Server 2022(16.x)\ncom.microsoft.sqlserver:mssql-jdbc (11.2.3.jre17)\nOracle Database Free\ncom.oracle.database.jdbc:ojdbc17 (23.9.0.25.07)\nby docker image: gvenzl/oracle-free:slim-faststart",
    "description": "About settings on databases",
    "tags": [],
    "title": "Database-related settings",
    "uri": "/docs/database/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "",
    "description": "Pages for issues, thinking and concepts",
    "tags": [],
    "title": "Issue/Thinking/Concept",
    "uri": "/issues/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Motivation When we are preparing data of RDB for tests, the tedious and tricky part is to write correct DML for data insertion. Foxglove is a library that helps you to generating data by auto schema-inspection and table facet(rules to generate data).\nWhile preparing data for unit tests over databases, the key things are:\nPreparing values for columns in WHERE clause of SQL or clause may FILTERING data(e.g. INNER JOIN).\nSome critical values to be asserted or counting number of results affected by exercised SQL.\nWhile tearing down the tests, you may like to delete only the data you have inserted.\nSpecify some fixed values to irrelevant columns could help\nThat is, how Foxglove helps you:\nJust provide values for specified columns.\nGive the critical values you need to check.\nDon’t have to care about irrelevant, non-nullable(and no default value) columns.\nOther data that is irrelevant to your tests will be generated automatically by Foxglove.\nPreparing data // Generates 4 rows with \"cr_brand \"fixed to \"Toyota\" and // 4 different values on \"cr_model\" var facet = JdbcTableFacet.builder(TABLE_CAR) .numberOfRows(4) .column(\"cr_brand\") .fixed(\"Toyota\") .column(\"cr_model\") .roundRobin(\"Corolla\", \"Camry\", \"RAV4\", \"Prius\") .build(); new JdbcDataGenerator(getDataSource()) .generate(facet); The data could be used for:\nThere could be 0 ~ 1 matched row for any query of the SQL\nSELECT * FROM ap_car WHERE cr_brand = ? AND cr_model = ? Since cr_created_at will be generated randomly by default, you can check the values of the column for the correctness of ordering.\nSELECT * FROM ap_car WHERE cr_brand = ? ORDER BY cr_created_at DESC Integration See JUnit 5 Quick Start for usage with JUnit 5.\nSee SpringFramework Quick Start for usage with SprinFramwork - JDBC Testing Support.\nRequirements Java 17+\nDocumentations Quick starts, Docs\nMaven Site, Javadocs(Maven Site)\nInstallation Maven pom.xml \u003crepositories\u003e \u003crepository\u003e \u003cid\u003efoxglove-repo\u003c/id\u003e \u003cname\u003eFoxglove Maven Repository\u003c/name\u003e \u003curl\u003ehttps://maven.pkg.github.com/mikelue/foxglove\u003c/url\u003e \u003csnapshots\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003c/snapshots\u003e \u003c/repository\u003e \u003c/repositories\u003e \u003cdependency\u003e \u003cgroupId\u003eguru.mikelue.foxglove\u003c/groupId\u003e \u003cartifactId\u003ecore\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e GitHub Maven registry authentication($HOME/.m2/settings.xml) \u003cservers\u003e \u003cserver\u003e \u003cid\u003efoxglove-repo\u003c/id\u003e \u003cusername\u003emikelue\u003c/username\u003e \u003cpassword\u003eyour_token\u003c/password\u003e \u003c/server\u003e \u003c/servers\u003e Don’t forget to create a PAT(personal access token) on GitHub.\nWoking with Maven registry(GitHub)\nGradle repositories { maven { name 'foxglove-repo' url 'https://maven.pkg.github.com/mikelue/foxglove' } } testImplementation 'guru.mikelue.foxglove:core:1.0-SNAPSHOT' SBT resolvers += \"foxglove-repo\" at \"https://maven.pkg.github.com/mikelue/foxglove\" libraryDependencies += \"guru.mikelue.foxglove\" % \"core\" % \"1.0-SNAPSHOT\" % Test ivysettings.xml \u003civysettings\u003e \u003csettings defaultResolver=\"chain\"/\u003e \u003cresolvers\u003e \u003cchain name=\"chain\"\u003e \u003cibiblio name=\"foxglove-repo\" m2compatible=\"true\" root=\"https://maven.pkg.github.com/mikelue/foxglove\" pattern=\"[organisation]/[module]/[revision]/[artifact]-[revision](-[classifier]).[ext]\"/\u003e \u003c/chain\u003e \u003c/resolvers\u003e \u003c/ivysettings\u003e Ivy \u003cdependency org=\"guru.mikelue.foxglove\" name=\"core\" rev=\"1.0-SNAPSHOT\" conf=\"test\"/\u003e Credits Thanks to Instancio project for its excellent data generation capabilities.",
    "description": "Welcome to the Foxglove. A library for generating data for RDB.",
    "tags": [],
    "title": "Introduction",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Introduction",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
