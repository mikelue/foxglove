package guru.mikelue.foxglove.jdbc;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import guru.mikelue.foxglove.ColumnMeta;
import guru.mikelue.foxglove.TupleAccessor;

import static java.util.Collections.unmodifiableList;

/**
 * Stateful loader for generated values after insert operation.
 *
 * This class will keep the metadata generated by {@link PreparedStatement#getGeneratedKeys()}.
 */
class GeneratedValueLoader {
	private final Logger logger = LoggerFactory.getLogger(GeneratedValueLoader.class);

	private final String[] askedGeneratedColumns;
	private ColumnMeta[] metaOfColumns = null;
	private TupleAccessorImpl.TupleSchema tupleSchema = null;

	GeneratedValueLoader(String[] askedGeneratedColumns)
	{
		this.askedGeneratedColumns = askedGeneratedColumns;
	}

	List<TupleAccessor> toTuples(ResultSet rs) throws SQLException
	{
		initMetadata(rs);

		var tempRows = new ArrayList<TupleAccessor>(rs.getFetchSize());

		var rowIndexOfGeneratedKeys = 0;
		while (rs.next()) {
			Map<ColumnMeta, Object> rowValues = new LinkedHashMap<ColumnMeta, Object>(metaOfColumns.length);

			for (var i = 0; i < metaOfColumns.length; i++) {
				rowValues.put(metaOfColumns[i], rs.getObject(i + 1));
			}

			var newTuple = tupleSchema.createTupleAccessor(rowValues, 0);
			logger.trace("Have fetched generated row: {}", newTuple);

			tempRows.add(newTuple);
			rowIndexOfGeneratedKeys++;
		}

		logger.debug("Have fetched [{}] generated keys.", rowIndexOfGeneratedKeys);

		return unmodifiableList(tempRows);
	}

	private void initMetadata(ResultSet rs) throws SQLException
	{
		if (metaOfColumns != null) {
			return;
		}

		if (askedGeneratedColumns.length == 0) {
			metaOfColumns = MetaUtils.getColumnMetaList(rs.getMetaData()).toArray(new ColumnMeta[0]);
			tupleSchema = new TupleAccessorImpl.TupleSchema(
				List.of(metaOfColumns)
			);
			return;
		}

		/*
		 * Since database like derby, sqlite would gives no column name by getGeneratedKeys(),
		 * we refine the column meta info here according to the asked generated columns.
		 */
		metaOfColumns = MetaUtils.getColumnMetaList(rs.getMetaData()).toArray(new ColumnMeta[0]);

		for (var i = 0; i < askedGeneratedColumns.length; i++) {
			var currentMeta = metaOfColumns[i];

			metaOfColumns[i] = new ColumnMeta(
				askedGeneratedColumns[i],
				currentMeta.properties(),
				currentMeta.typeName(), currentMeta.jdbcType(),
				currentMeta.size(), currentMeta.decimalDigits()
			);
		}

		tupleSchema = new TupleAccessorImpl.TupleSchema(
			List.of(metaOfColumns)
		);
		// :~)

		if (logger.isDebugEnabled()) {
			logger.debug("Loaded metadata for getGeneratedKeys(): {}",
				Stream.of(metaOfColumns)
					.map(col ->
						String.format("%s(%s)", col.name(), col.jdbcType())
					)
					.toList()
			);
		}
	}
}
