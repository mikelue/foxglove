package guru.mikelue.foxglove.setting;

import java.sql.JDBCType;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import guru.mikelue.misc.testlib.AbstractTestBase;

import guru.mikelue.foxglove.ColumnMeta;
import guru.mikelue.foxglove.ColumnMeta.Property;

import static guru.mikelue.foxglove.ColumnMeta.Property.*;
import static guru.mikelue.foxglove.ColumnMetaTestUtils.newColumnMeta;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;
import static org.junit.jupiter.params.provider.Arguments.arguments;

public class DataSettingTest extends AbstractTestBase {
	public DataSettingTest() {}

	@BeforeEach
	void setup() {}

	@AfterEach
	void tearDown() {}

	/**
	 * Tests the setting-up for properties of auto-generating.
	 */
	@ParameterizedTest
	@MethodSource
	void isAutoGenerating(
		ColumnMeta sampleColumn,
		boolean expectedGenerating
	) {
		var testedSetting = DataSetting.defaults()
			.givenType("status")
				.useSupplier(() -> "ACTIVE")
			.columnMatcher(columnMeta ->
				columnMeta.jdbcType() == JDBCType.ARRAY
			)
				.decideSupplier(columnMeta -> () -> new Object[0])
			.excludeWhen(columnMeta ->
				columnMeta.name().startsWith("audit_")
			);

		assertThat(testedSetting.isAutoGenerating(sampleColumn))
			.isEqualTo(expectedGenerating);
	}
	static Arguments[] isAutoGenerating()
	{
		return new Arguments[] {
			// Excluded by custom rule
			arguments(newColumnMeta("audit_not1"), false),
			// supported types by custom matcher
			arguments(sampleColumn(JDBCType.ARRAY, GENERATED), true),
			/*
			 * Not auto-generated by default
			 */
			arguments(sampleColumn(AUTO_INCREMENT), false),
			arguments(sampleColumn(GENERATED), false),
			// :~)
			// Supported types
			arguments(sampleColumn(JDBCType.VARCHAR, NULLABLE), true),
			// Supported type names
			arguments(newColumnMeta("status", NULLABLE), true),
			// Not supported types
			arguments(sampleColumn(JDBCType.ROWID, GENERATED), false)
		};
	}

	/**
	 * Tests the resolving of suppliers by different column properties.
	 */
	@ParameterizedTest
	@MethodSource
	void resolveSupplier(
		ColumnMeta sampleColumnMeta,
		String expectedValue
	)
	{
		var testedSetting = new DataSetting();

		testedSetting.givenType(JDBCType.VARCHAR)
			.useSupplier(() -> "test-string-1");
		testedSetting.givenType(JDBCType.OTHER) // Should have lower priority of all
			.useSupplier(() -> "test-string-error");

		testedSetting.givenType("LINT CHAR") // Should have middle priority(for name of "cl_special")
			.useSupplier(() -> "test-string-2");

		testedSetting.columnMatcher(c -> c.name().equals("cl_special"))
			.useSupplier(() -> "test-string-3");

		var testedSupplier = testedSetting.resolveSupplier(sampleColumnMeta)
			.get();

		assertThat(testedSupplier.get())
			.isEqualTo(expectedValue);
	}

	static Arguments[] resolveSupplier()
	{
		return new Arguments[] {
			arguments( // By column matcher
				newColumnMeta("cl_special", JDBCType.OTHER),
				"test-string-3"
			),
			arguments( // By type name
				newColumnMeta("cl_diff", "LINT CHAR", JDBCType.OTHER),
				"test-string-2"
			),
			arguments( // By JDBC type
				newColumnMeta("cl_another", JDBCType.VARCHAR),
				"test-string-1"
			),
		};
	}

	/**
	 * Tests the nullable value generation.
	 */
	@Test
	void generateNullable()
	{
		var testedSetting = new DataSetting()
			.givenType(JDBCType.VARCHAR)
				.useSupplier(() -> "not-null-value")
			.generateNull(2);

		var sampleColumn = sampleColumn(NULLABLE);

		var supplier = testedSetting.resolveSupplier(sampleColumn)
			.get();

		await()
			.atMost(5, SECONDS)
			.untilAsserted(() -> {
				assertThat(supplier.get())
					.isNull();
			});
	}

	private static ColumnMeta sampleColumn(Property... properties)
	{
		return newColumnMeta("any_column", JDBCType.VARCHAR, properties);
	}

	private static ColumnMeta sampleColumn(JDBCType jdbcType, Property... properties)
	{
		return newColumnMeta("any_column", jdbcType, properties);
	}
}
